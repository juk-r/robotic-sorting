# Моделирование роботизированного сортировочного центра

## Основные предположения

В пункты получения сортировочного логистического центра непрерывно поступают посылки, которые роботы должны сортировать - развести в соответствующие пункты назначения центра.

Сортировочный центр - прямоугольная площадка, разделённая на клетки, некоторые из которых помечены, как пункты получения и назначения для посылок. Также возможно указать, что роботы не могут находится на клетке - это стена.

Роботы могут двигаться вперед и поворачиваться в одном из 4 направлений. Роботы передвигаются по командам системы управления за различные, заданные моделью, дискретные времена:
- бездействие
- движение на одну клетку вперед
- поворот на 90 градусов
- взятие посылки (в пункте получения)
- сдача посылки (в пункте назначения)

В момент получения посылки роботом, становится известен её пункт назначения - куда нужно отвести.

## Установка Администратором
предполагается, что уже установлены:
- python 3.12
- [simpy](https://github.com/esemble/simpy) (библиотека python)

перейти в нужную директорию, например в домашнюю:
- `cd ~`

склонировать репозиторий:
- `git clone https://github.com/juk-r/robotic-sorting.git`

добавить в PYTHONPATH, например для linux:
- `export PYTHONPATH="${PYTHONPATH}:~/robotic-sorting"`

запустить пример:
- `python robotic-sorting/examples/circle_on_small.py`

проверить, что в консоль выведено количество посылок: `model.delivered_mails = 24`

## Запуск
Запуск производится командой следующего вида (из директории содержащей `robotic-sorting`):
```bash
python robotic-sorting -map FILE -type FILE -position FILE -distribution FILE -algorithm FILE -mode {run,record,average} -time TIME [-output OUTPUT] [-count COUNT]
```
с параметрами:
- `-map` - файл конфигурации карты
- `-type` - файл конфигурации типа роботов, времен действий
- `-position` - файл конфигурации расположения роботов
- `-distribution` - файл конфигурации распределения вероятности
- `-algorithm` - файл алгоритма
- `-time` - модельное время, которое будет работать модель
- `-mode` - тип запуска
    - `run` - выводит количество доставленных посылок
    - `record` - выводит все действия роботов в формате `csv`, рекомендуется указывать файл вывода
    - `average` - выводит количество доставленных посылок и стандартное отклонение при указанном количестве запусков
- `-output` - файл в который выводится результат, по умолчанию выводится в стандартный `stdout`
- `-count` - количество запусков для типа `average`

## Конфигурация модели Пользователем

Конфигурация задается несколькими `.json` файлами и выбранным алгоритмом. Запуск производится из консоли.

### Карта склада
Конфигурация склада задается файлом `.json`, соответствующим [схеме](/data/schemas/map-v1-schema.json), содержит:
- `span` - расстояние между клетками
- `cells` - двумерный массив клеток, каждая из которых содержит необязательные:
    - `free` - может ли робот находиться, по умолчанию может: `true`
    - `inputId` - уникальный номер пункта получения, по умолчанию его нет
    - `outputId` - уникальный номер пункта отправления, по умолчанию его нет

Можно посмотреть [пример карты](/data/small_map.json).

### Времена выполнения команд роботов
Конфигурация задается файлом `.json`, соответствующим [схеме](/data/schemas/robot-type-v1-schema.json), содержит:
- `timeToMove` - время для движения вперед на 1 клетку
- `timeToTurn`- время для поворота на 90 градусов
- `timeToTake`  - время, чтобы взять груз
- `timeToPut` - время, чтобы положить груз

Можно посмотреть [пример](/data/example/robot-type.json).

### Расположение роботов
Конфигурация задается файлом `.json`, соответствующим [схеме](/data/schemas/position-schema.json), содержит:
- `robots` - список, элементы которого содержат:
    - `x` - позиция по 1 координате, считая с 0
    - `y` - позиция по 2 координате, считая с 0
    - `direction` - направление одно из:
        - `up` - вверх
        - `left` - влево
        - `down` - вниз
        - `right` - вправо

Можно посмотреть [пример](/data/example/position.json).

### Распределение вероятностей направлений
Конфигурация склада задается файлом `.json`, соответствующим [схеме](/data/schemas/destination-distribution-schema.json), содержит:
- `distribution` объект, в котором:
    - ключ - уникальный номер пункта отправления
    - значения - вероятность, что новую посылку нужно отвести в этот пункт отправления

Можно посмотреть [пример распределения](/data/sample-distribution.json).

## Архитектура моделирования для Программиста

Модель разделена на 2 части: сменная реализация алгоритма управления и остальная часть модели, которая проверяет, что роботы не сталкиваются и посылки обрабатываются корректно.

### Модель склада

Чтобы проверить, что роботы не сталкиваются, достаточно проверить, что в любой момент времени никакие два робота не используют одну клетку:
- не находятся в одной клетке
- один не движется в клетку, где стоит другой
- один не движется в клетку, откуда движется другой
- не движутся в одну клетку

Это можно проверять следующим образом:
- каждый робот перед началом движения в новую клетку резервирует ее и после окончания движения разрезервирует предыдущую.
- если клетка уже зарезервированная и робот пытается её зарезервировать, то роботы точно столкнутся.

### Модель системы управления

#### Требования
Модель системы управления реализуется на python специальным классом, который наследуется от класса [`Brain`](/brains/brain.py#L14) и состоит из методов:
- `new_robot(Robot)`, будет вызван для каждого добавленного робота
- `get_next_action(Robot) -> Robot.Action`, вызывается моделью склада для каждого робота, метод возвращает предстоящее (одно из 5) действие для данного робота. Если действие приведет к столкновению роботов, то оно не выполняется и вызывается `collision_callback`.
- `collision_callback(Robot) -> None`, вызывается моделью склада, если полученное действие из `get_next_action` приведет к столкновению роботов. Не обязательный метод, если метод не представлен, то команда, приводящей к столкновению, вызывается исключение.

В одном файле `.py`, содержащем выбранный алгоритм, должен быть один и только один класс, наследованный от `Brain`.

#### Информация о состоянии модели склада
Модель система управления может получить всю информацию о текущем состоянии модели склада из поля `_model` (типа `Model`), которое наследуется от класса `Brain`.

Класс `Model` содержит неизменяемую часть - карта склада - поле `map` (типа `Map`), и переменною - состояние роботов - поле `robots` (список роботов типа `Robot`).

Карта склада может быть получена из полей карты [`Map`](/structures.py#L66):
- `inputs` - пункты получения - словарь id: координаты
- `outputs` - пункты назначения - словарь id: координаты
- `n`, `m` - размеры карты по `x` и `y`
- метод `has(Position)->bool` - проверка существования клетки с заданной координатой
- метод  `[Position]` (индекс) - получит клетку (типа `Cell`), которая содержит:
    - `free` (`bool`) - может ли робот находиться на ней
    - `input_id` (`int`) - id пункта получения или `None`, если нет
    - `output_id` (`int`) - id пункта отправления или `None`, если нет
    - `reserved` (`bool`) - какой-то робот, зарезервировал клетку

О текущем состоянии модели можно узнать из следующих полей роботов (класс [`Robot`](/robot.py#L19)):
- `position` - координаты клетки, на которой находится робот
    - `x` (`int`)
    - `y` (`int`)
- `direction` (enum) - направление одно из 4 
- `mail` - посылка, которую везет робот или `None`, если нет посылки:
    - `id` (`int`)- уникальный номер посылки
    - `destination` (`int`) - направление, в которое нужно доставить
- `type` - тип робота, неизменяемая информация о времени действиях:
    - `time_to_move` (`int`) - время, чтобы проехать 1 клетку
    - `time_to_turn` (`int`) - время, чтобы повернуть на 90 градусов
    - `time_to_take` (`int`) - время, чтобы взять посылку
    - `time_to_put` (`int`) - время, чтобы положить одну посылку

### Реализация правил моделирования

С помощью классов [`Robot`](robot.py#L19), [`Map`](structures.py#L66), [`Cell`](cell.py#L20), [`MailFactory`](mail_factories/mail_factory.py), [`Brain`](brains/brain.py#L14) реализовано следующим образом:
- Каждая клетка может быть зарезервирована одним роботом и не зарезервирована тем же роботом; методы `Cell.reserve` и `Cell.unreserve`
- Клетка - пункт получения, вызывают `MailFactory` со своим *id*, чтобы получать сгенерированные направления позже.
- клетка - пункт получения, когда робот вызывает `Cell.get_input` для получения новой посылки, клетка вызывает сохраненный вызов `MailFactory`.
- Во время запуска каждый робот резервирует клетку, в которой он находится.
- После выполнения действия робот вызывает `Brain.get_next_action`:
    - если действие - бездействие, робот ждет, пока вызовет `Robot.abort`
    - если действие - движение, робот резервирует следующую клетку, ждет время для перемещения, отменяет резервирование предыдущей клетки; если следующей клетки не существует, возникает исключение `PositionOutOfMap`
    - если данная команда приведет к столкновению, команда не выполняется и вызывается метод системы управления `collision_callback`, затем заново `get_next_action`.
    - если действие — поворот, робот ждет время для поворота
    - если действие — получить, робот пытается забрать посылку и ждет время для приема; если у робота уже есть посылка, возникает `DoubleMailTake`; если клетка не является пунктом приема, возникает `NotInputCell`.
    - если действие - положить, робот пытается отправить посылку из клетки и ждет время для отправки; если у робота нет посылки, возникает `MailToPutAbsence`; если направление посылки не совпадает с пунктом отправления или клетка не является пунктом отправления, возникает `IncorrectOutput`.
