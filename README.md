# Моделирование роботизированного сортировочного центра

## Основные предположения
В сортировочный логистических центре непрерывно поступают грузы, которые роботы должны сортировать - развести в соответствующие места центра.
Сортировочный центр - прямоугольная площадка, разделённая на клетки, некоторые из которых помечены как пункты получения и назначения для грузов.
Роботы передвигаются по клеткам в одном из четырёх направлений и считается, что у роботов бесконечное ускорение.
Каждый груз берётся роботом в пункте получения и соответствует одному из пункту назначения.
Пункт назначения выбирается случайным образом и становится известным в момент получения груза.

## Установка
требуются для работы:
- python 3.12
- [simpy](https://github.com/esemble/simpy)

склонировать репозиторий:
- `git clone https://github.com/juk-r/robotic-sorting.git`

добавить в PYTHONPATH, например:
- `export PYTHONPATH="${PYTHONPATH}:/path/to/robot-sorting"`

Теперь можно проверь, что все работает, запустив [примеры](/examples/), (узнать [как устроены примеры](/docs/ru/guide.md))


## Архитектура модели

Модель разделена на 2 части: проверка, что роботы не сталкиваются и грузы обрабатываются правильно; система управления, которая выдает роботом команды.

### Проверка

Чтобы проверить что роботы не сталкиваются, достаточно проверить, что в любой момент времени никакие два робота не используют одну клетку:
- не находятся в одной клетке
- один не движется в клетку, где стоит другой
- один не движется в клетку, откуда движется другой
- не движутся в одну клетку
Это можно проверять следующим образом:
- каждый робот перед началом движения в новую клетку резервирует ее и после окончания движения разрезервирует предыдущую.
- если клетка уже зарезервированная и робот пытается её зарезервировать, то точно роботы столкнутся.

### Интерфейс системы управления

Описан в классе [`Brain`](brains/brain.py#L14) и состоит из двух методов:
- `new_robot(Robot)`, будет вызван для каждого добавленного робота
- `get_next_action(Robot) -> Robot.Action`, вызывается роботами, возвращает следующее действие, чтобы выполнить роботом, одно из: бездействие, движения, поворот, взять или положить груз.

### Реализация проверки

С помощью классов [`Robot`](robot.py#L19), [`Map`](structures.py#L66), [`Cell`](cell.py#L20), [`MailFactory`](mail_factories/mail_factory.py), [`Brain`](brains/brain.py#L14) реализовано следующим образом:
- Каждая клетка может быть зарезервирована одним роботом и не зарезервирована тем же роботом; методы `Cell.reserve` и `Cell.unreserve`
- Клетка-пункт получения, вызывают `MailFactory` со своим *id*, чтобы получать сгенерированные направления позже.
- клетка-пункт получения, когда робот вызывает `Cell.get_input` для получения нового груза, клетка вызывает сохраненный вызов `MailFactory`.
- Во время запуска каждый робот резервирует клетку, в которой он находится.
- После выполнения действия робот вызывает `Brain.get_next_action`:
    - если действие - idle, робот ждет, пока мозг вызовет `Robot.abort`
    - если действие - движение, робот резервирует следующую клетку, ждет время для перемещения, отменяет резервирование предыдущей клетки; если следующая клетка не существует или уже зарезервирована, возникает исключение PositionOutOfMapException или CellIsReservedException соответственно;
    - если действие — поворот, робот ждет время для поворота
    - если действие — принять, робот пытается забрать груз из клетки и ждет время для приема; если у робота уже есть груз, возникает `RobotWithMailException`; если клетка не является пунктом приема, возникает `NotInputCellException`.
    - если действие - положить, робот пытается отправить груз из клетки и ждет время для отправки; если у робота нет груза, возникает `RobotWithoutMailException`; если направление груза не совпадает с пунктом отправления или клетка не является пунктом отправления, возникает `IncorrectOutputException`.
