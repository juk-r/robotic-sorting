# Моделирование роботизированного сортировочного центра

## Основные предположения

В пункты получения сортировочный логистических центре непрерывно поступают посылки, которые роботы должны сортировать - развести в соответствующие пункты получения центра.

Сортировочный центр - прямоугольная площадка, разделённая на клетки, некоторые из которых помечены как пункты получения и назначения для посылок.

Роботы могут двигаться вперед и поворачиваться в одном из 4 направлений. Роботы передвигаются по командам системы управления за различные, заданные моделью, дискретные времена:
- бездействие
- движение на одну клетку вперед
- поворот на 90 градусов
- взять посылку
- положить посылку

Каждая посылка берётся роботом в пункте получения и соответствует одному из пункту назначения.

Пункт назначения посылки становится известным в момент получения её роботом.

## Установка Администратором
требуются для работы:
- python 3.12
- [simpy](https://github.com/esemble/simpy) (библиотека python)

перейти в нужную директорию, например в домашнюю:
- `cd ~`

склонировать репозиторий:
- `git clone https://github.com/juk-r/robotic-sorting.git`

добавить в PYTHONPATH, например для linux:
- `export PYTHONPATH="${PYTHONPATH}:~/robotic-sorting"`

запустить пример:
- `python robotic-sorting/examples/circle_on_small.py`

проверить, что в консоль выведено количество посылок: `model.delivered_mails = 24`

## Конфигурация модели Пользователем

Конфигурация задается несколькими `.json` файлами и выбранным алгоритмом. Запуск производится из консоли

### Карта склада
Конфигурация склада задается файлом `.json`, соответствующим [схеме](/data/schemas/map-v1-schema.json), содержит:
- `span` - расстояние между клетками
- `cells` - двумерный массив клеток, каждая из которых содержит необязательные:
    - `free` - может ли робот находиться, по умолчанию может: `true`
    - `inputId` - уникальный номер пункта получения, по умолчанию его нет
    - `outputId` - уникальный номер пункта отправления, по умолчанию его нет

Можно посмотреть [пример карты](/data/small_map.json).

### Времена выполнения команд роботов
Конфигурация задается файлом `.json`, соответствующим [схеме](/data/schemas/robot-type-v1-schema.json), содержит:
- `timeToMove` - время для движения вперед на 1 клетку
- `timeToTurn`- время для поворота на 90 градусов
- `timeToTake`  - время, чтобы взять груз
- `timeToPut` - время, чтобы положить груз

Можно посмотреть [пример](/data/example/robot-type.json).

### Расположение роботов
Конфигурация задается файлом `.json`, соответствующим [схеме](/data/schemas/position-schema.json), содержит:
- `robots` - список, элементы которого содержат:
    - `x` - позиция по 1 координате, считая с 0
    - `y` - позиция по 2 координате, считая с 0
    - `direction` - направление одно из:
        - `up` - вверх
        - `left` - влево
        - `down` - вниз
        - `right` - вправо

Можно посмотреть [пример](/data/example/position.json).

### Распределение вероятностей направлений
Конфигурация склада задается файлом `.json`, соответствующим [схеме](/data/schemas/destination-distribution-schema.json), содержит:
- `distribution` объект, в котором:
    - ключ - уникальный номер пункта отправления
    - значения - вероятность, что новую посылку нужно отвести в этот пункт отправления

Можно посмотреть [пример распределения](/data/sample-distribution.json).

### Запуск и результат
Запуск производится командой следующего вида (из директории содержащей `robotic-sorting`):
```bash
python robotic-sorting -map FILE -type FILE -position FILE -distribution FILE -algorithm FILE -mode {run,record,average} -time TIME [-output OUTPUT] [-count COUNT]
```
с параметрами:
- `-map` - файл конфигурации карты
- `-type` - файл конфигурации типа роботов, времен действий
- `-position` - файл конфигурации расположения роботов
- `-distribution` - файл конфигурации распределения вероятности
- `-algorithm` - файл алгоритма, [с описанными требованиями](#требования)
- `time` - модельное время, которое будет работать модель
- `mode` - тип запуска
    - `run` - выводит количество доставленных посылок
    - `record` - выводит все действия роботов в формате `csv`, рекомендуется указывать файл вывода
    - `average` - выводит количество доставленных посылок и стандартное отклонение при указанном количестве запусков
- `-output` - файл в который выводится результат, по умолчания `stdout`
- `-count` - количество запусков для типа `average`

## Архитектура моделирования для Программиста

Модель разделена на 2 части: сменная реализация алгоритма управления и остальная часть модели, которая проверяет, что роботы не сталкиваются и посылки обрабатываются корректно.

### Модель склада

Чтобы проверить что роботы не сталкиваются, достаточно проверить, что в любой момент времени никакие два робота не используют одну клетку:
- не находятся в одной клетке
- один не движется в клетку, где стоит другой
- один не движется в клетку, откуда движется другой
- не движутся в одну клетку

Это можно проверять следующим образом:
- каждый робот перед началом движения в новую клетку резервирует ее и после окончания движения разрезервирует предыдущую.
- если клетка уже зарезервированная и робот пытается её зарезервировать, то роботы точно столкнутся.

### Модель системы управления

#### Требования
Модель системы управления должна наследоваться от класса [`Brain`](/brains/brain.py#L14) и состоять из двух методов:
- `new_robot(Robot)`, будет вызван для каждого добавленного робота
- `get_next_action(Robot) -> Robot.Action`, вызывается роботами, возвращает следующее действие, чтобы выполнить роботом, одно из: бездействие, движения, поворот, взять или положить посылку.

Не обязательный метод, если не представлен, при команде, приводящей к столкновению, вызывается исключение:
- `next_action_on_collision(Robot) -> Robot.Action`, вызывается роботами, если полученное действие от `get_next_action` приведет к столкновению роботов, возвращает действие робота.

В одном файле `.py`, содержащем выбранный алгоритм, должен быть ровно один класс, наследованный от `Brain`, - он выбирается при запуске из консоли.

#### Информация о состоянии
Система управления может получить всю информацию о текущем состоянии модели, содержащейся в классе [`Model`](/modelling.py) в поле `brain._model`, которое содержит ``map`, `robots`.

Конфигурации склада может быть получена из полей карты [`Map`](/structures.py#L66):
- `inputs` - координаты пунктов получения
- `outputs` - координаты пунктов назначения
- `n`, `m` - размеры карты по `x` и `y`
- метод `has(Position)->bool` - проверка существования клетки с координатой
- метод  `[Position]` - получит клетку, которая содержит:
    - `free` - может ли робот находиться на ней
    - `input_id` - id пункта получения или `None`, если нет
    - `output_id` - id пункта отправления или `None`, если нет
    - `reserved` - какой-то робот, зарезервировал клетку

О текущем состоянии модели можно узнать из следующих полей роботов (класс [`Robot`](/robot.py#L19)):
- `position` - координаты клетки, на которой находится робот
    - `x`
    - `y`
- `direction` - направление
- `mail` - посылка, которую везет робот или `None`, если нет посылки:
    - `id` - уникальный номер посылки
    - `destination` - направление, в которое нужно доставить
- `type` - тип робота, информация о времени действиях:
    - `time_to_move` - время, чтобы проехать 1 клетку
    - `time_to_turn` - время, чтобы повернуть на 90 градусов
    - `time_to_take` - время, чтобы взять посылку
    - `time_to_put` - время, чтобы положить одну посылку

### Реализация правил моделирования

С помощью классов [`Robot`](robot.py#L19), [`Map`](structures.py#L66), [`Cell`](cell.py#L20), [`MailFactory`](mail_factories/mail_factory.py), [`Brain`](brains/brain.py#L14) реализовано следующим образом:
- Каждая клетка может быть зарезервирована одним роботом и не зарезервирована тем же роботом; методы `Cell.reserve` и `Cell.unreserve`
- Клетка-пункт получения, вызывают `MailFactory` со своим *id*, чтобы получать сгенерированные направления позже.
- клетка-пункт получения, когда робот вызывает `Cell.get_input` для получения новой посылки, клетка вызывает сохраненный вызов `MailFactory`.
- Во время запуска каждый робот резервирует клетку, в которой он находится.
- После выполнения действия робот вызывает `Brain.get_next_action`:
    - если действие - бездействие, робот ждет, пока вызовет `Robot.abort`
    - если действие - движение, робот резервирует следующую клетку, ждет время для перемещения, отменяет резервирование предыдущей клетки; если следующей клетки не существует или она уже зарезервирована, возникает исключение `PositionOutOfMap` или `RobotCollision` соответственно;
    - если действие — поворот, робот ждет время для поворота
    - если действие — получить, робот пытается забрать посылку и ждет время для приема; если у робота уже есть посылка, возникает `DoubleMailTake`; если клетка не является пунктом приема, возникает `NotInputCell`.
    - если действие - положить, робот пытается отправить посылку из клетки и ждет время для отправки; если у робота нет посылки, возникает `MailToPutAbsence`; если направление посылки не совпадает с пунктом отправления или клетка не является пунктом отправления, возникает `IncorrectOutput`.