# Моделирование роботизированного сортировочного центра

## Основные предположения
В сортировочный логистических центре непрерывно поступают грузы, которые роботы должны сортировать - развести в соответствующие места центра.

Сортировочный центр - прямоугольная площадка, разделённая на клетки, некоторые из которых помечены как пункты получения и назначения для грузов.

Роботы передвигаются по клеткам в одном из четырёх направлений и считается, что у роботов бесконечное ускорение.

Каждый груз берётся роботом в пункте получения и соответствует одному из пункту назначения.

Пункт назначения выбирается случайным образом и становится известным в момент получения груза.

## Архитектура моделирования

Модель разделена на 2 части: сменная реализация алгоритма управления, остальная часть модели - проверка, что роботы не сталкиваются и грузы обрабатываются корректно.

### Модель склада

Чтобы проверить что роботы не сталкиваются, достаточно проверить, что в любой момент времени никакие два робота не используют одну клетку:
- не находятся в одной клетке
- один не движется в клетку, где стоит другой
- один не движется в клетку, откуда движется другой
- не движутся в одну клетку
Это можно проверять следующим образом:
- каждый робот перед началом движения в новую клетку резервирует ее и после окончания движения разрезервирует предыдущую.
- если клетка уже зарезервированная и робот пытается её зарезервировать, то точно роботы столкнутся.

### Модель системы управления

Модель системы управления должна наследоваться от класса [`Brain`](/brains/brain.py#L14) и состоять из двух методов:
- `new_robot(Robot)`, будет вызван для каждого добавленного робота
- `get_next_action(Robot) -> Robot.Action`, вызывается роботами, возвращает следующее действие, чтобы выполнить роботом, одно из: бездействие, движения, поворот, взять или положить груз.

Информация о модели хранится в классе [`Model`](/modelling.py) в поле `brain._model`, которое содержит ``map`, `robots`.

Конфигурации склада может быть получена из полей карты [`Map`](/structures.py#L66):
- `inputs` - координаты пунктов получения
- `outputs` - координаты пунктов назначения
- `n`, `m` - размеры карты по `x` и `y`
- метод `has(Position)->bool` - проверка существования клетки с координатой
- метод  `[Position]` - получит клетку, которая содержит:
    - `free` - может ли робот находиться на ней
    - `input_id` - id пункта получения или `None`, если нет
    - `output_id` - id пункта отправления или `None`, если нет
    - `reserved` - какой-то робот, зарезервировал клетку

О текущем состоянии модели можно узнать из следующих полей роботов (класс [`Robot`](/robot.py#L19)):
- `position` - координаты клетки, на которой находится робот
    - `x`
    - `y`
- `direction` - направление
- `mail` - груз, которой везет робот или `None`, если нет груза:
    - `id` - уникальный номер груза
    - `destination` - направление, в которое нужно доставить
- `type` - тип робота, информация о времени действиях:
    - `time_to_move` - время, чтобы проехать 1 клетку
    - `time_to_turn` - время, чтобы повернуть на 90 градусов
    - `time_to_take` - время, чтобы взять посылку
    - `time_to_put` - время, чтобы положить одну посылку

### Реализация правил моделирования

С помощью классов [`Robot`](robot.py#L19), [`Map`](structures.py#L66), [`Cell`](cell.py#L20), [`MailFactory`](mail_factories/mail_factory.py), [`Brain`](brains/brain.py#L14) реализовано следующим образом:
- Каждая клетка может быть зарезервирована одним роботом и не зарезервирована тем же роботом; методы `Cell.reserve` и `Cell.unreserve`
- Клетка-пункт получения, вызывают `MailFactory` со своим *id*, чтобы получать сгенерированные направления позже.
- клетка-пункт получения, когда робот вызывает `Cell.get_input` для получения нового груза, клетка вызывает сохраненный вызов `MailFactory`.
- Во время запуска каждый робот резервирует клетку, в которой он находится.
- После выполнения действия робот вызывает `Brain.get_next_action`:
    - если действие - бездействие, робот ждет, пока вызовет `Robot.abort`
    - если действие - движение, робот резервирует следующую клетку, ждет время для перемещения, отменяет резервирование предыдущей клетки; если следующей клетки не существует или она уже зарезервирована, возникает исключение `PositionOutOfMap` или `RobotCollision` соответственно;
    - если действие — поворот, робот ждет время для поворота
    - если действие — получить, робот пытается забрать груз и ждет время для приема; если у робота уже есть груз, возникает `DoubleMailTake`; если клетка не является пунктом приема, возникает `NotInputCell`.
    - если действие - положить, робот пытается отправить груз из клетки и ждет время для отправки; если у робота нет груза, возникает `MailToPutAbsence`; если направление груза не совпадает с пунктом отправления или клетка не является пунктом отправления, возникает `IncorrectOutput`.

## Установка
требуются для работы:
- python 3.12
- [simpy](https://github.com/esemble/simpy) (библиотека python)

склонировать репозиторий:
- `git clone https://github.com/juk-r/robotic-sorting.git`

добавить в PYTHONPATH, например  для linux:
- `export PYTHONPATH="${PYTHONPATH}:/path/to/robot-sorting"`

проверить пример, должно вывестись количество доставленых грузов:
- `python examples/circle_on_small.py`

## Конфигурация модели
### Склад/карта
Конфигурация склада задается файлом `.json`, соответствующим [схеме](/data/schemas/map-v1-schema.json), содержит:
- `span` - расстояние между клетками
- `cells` - двумерный массив клеток, содержащих необязательные:
    - `free` - может ли робот находиться
    - `inputId` - уникальный номер пункта получения
    - `outputId` - уникальный номер пункта отправления

Можно посмотреть [примеры карт](/data/).

### Алгоритм и роботы
Задаются исполняемым `.py` файлом, [описанным в примерах](/docs/ru/guide.md).

Результат моделирования сохраняется выбранным методом:
- `model.record_actions(mail_count, file_path))` - записать все действия роботов
- `model.test(time, count)` - получить среднее количество доставленных грузов и отклонение


!!! соблюдать правила
