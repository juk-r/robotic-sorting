# Моделирование роботизированного сортировочного центра

## Основные предположения

В пункты получения сортировочный логистических центре непрерывно поступают посылки, которые роботы должны сортировать - развести в соответствующие пункты получения центра.

Сортировочный центр - прямоугольная площадка, разделённая на клетки, некоторые из которых помечены как пункты получения и назначения для посылок.

Роботы могут двигаться вперед и поворачиваться в одном из 4 направлений. Роботы передвигаются по командам системы управления за различные, заданные моделью, дискретные времена:
- бездействие
- движение на одну клетку вперед
- поворот на 90 градусов
- взять посылку
- положить посылку

Каждая посылка берётся роботом в пункте получения и соответствует одному из пункту назначения.

Пункт назначения посылки становится известным в момент получения её роботом.

## Установка
требуются для работы:
- python 3.12
- [simpy](https://github.com/esemble/simpy) (библиотека python)

перейти в нужную директорию, например в домашнюю:
- `cd ~`

склонировать репозиторий:
- `git clone https://github.com/juk-r/robotic-sorting.git`

добавить в PYTHONPATH, например для linux:
- `export PYTHONPATH="${PYTHONPATH}:~/robotic-sorting"`

запустить пример:
- `python robotic-sorting/examples/circle_on_small.py`

проверить, что в консоль выведено количество посылок: `model.delivered_mails = 24`

## Конфигурация модели
### Карта склада
Конфигурация склада задается файлом `.json`, соответствующим [схеме](/data/schemas/map-v1-schema.json), содержит:
- `span` - расстояние между клетками
- `cells` - двумерный массив клеток, каждая из которых содержит необязательные:
    - `free` - может ли робот находиться, по умолчанию может: `true`
    - `inputId` - уникальный номер пункта получения, по умолчанию его нет
    - `outputId` - уникальный номер пункта отправления, по умолчанию его нет

Можно посмотреть [пример карты](/data/small_map.json).

### Распределение вероятностей направлений
Конфигурация склада задается файлом `.json`, соответствующим [схеме](/data/schemas/destination-distribution-schema.json), содержит:
- `distribution` объект, в котором:
    - ключ - уникальный номер пункта отправления
    - значения - вероятность, что новую посылку нужно отвести в этот пункт отправления

Можно посмотреть [пример распределения](/data/sample-distribution.json).

### Алгоритм и роботы
Выбор алгоритма управления складом, свойства роботов и их начальное местоположение задаются исполняемым `.py` файлом, [описанным в примерах](/docs/ru/guide.md).

### Запуск и результат
Результат моделирования сохраняется выбранным методом:
- `model.record_actions(mail_count, file_path))` - записать все действия роботов
- `model.test(time, count)` - получить среднее количество доставленных посылок и отклонение

## Архитектура моделирования

Модель разделена на 2 части: сменная реализация алгоритма управления и остальная часть модели, которая проверяет, что роботы не сталкиваются и посылки обрабатываются корректно.

### Модель склада

Чтобы проверить что роботы не сталкиваются, достаточно проверить, что в любой момент времени никакие два робота не используют одну клетку:
- не находятся в одной клетке
- один не движется в клетку, где стоит другой
- один не движется в клетку, откуда движется другой
- не движутся в одну клетку

Это можно проверять следующим образом:
- каждый робот перед началом движения в новую клетку резервирует ее и после окончания движения разрезервирует предыдущую.
- если клетка уже зарезервированная и робот пытается её зарезервировать, то роботы точно столкнутся.

### Модель системы управления

Модель системы управления должна наследоваться от класса [`Brain`](/brains/brain.py#L14) и состоять из двух методов:
- `new_robot(Robot)`, будет вызван для каждого добавленного робота
- `get_next_action(Robot) -> Robot.Action`, вызывается роботами, возвращает следующее действие, чтобы выполнить роботом, одно из: бездействие, движения, поворот, взять или положить посылку.

Не обязательный метод, если не представлен, при команде, приводящей к столкновению, вызывается исключение:
- `next_action_on_collision(Robot) -> Robot.Action`, вызывается роботами, если полученное действие от `get_next_action` приведет к столкновению роботов, возращает действие робота.

Система управления может получить всю информацию о текущем состоянии модели, содержащейся в классе [`Model`](/modelling.py) в поле `brain._model`, которое содержит ``map`, `robots`.

Конфигурации склада может быть получена из полей карты [`Map`](/structures.py#L66):
- `inputs` - координаты пунктов получения
- `outputs` - координаты пунктов назначения
- `n`, `m` - размеры карты по `x` и `y`
- метод `has(Position)->bool` - проверка существования клетки с координатой
- метод  `[Position]` - получит клетку, которая содержит:
    - `free` - может ли робот находиться на ней
    - `input_id` - id пункта получения или `None`, если нет
    - `output_id` - id пункта отправления или `None`, если нет
    - `reserved` - какой-то робот, зарезервировал клетку

О текущем состоянии модели можно узнать из следующих полей роботов (класс [`Robot`](/robot.py#L19)):
- `position` - координаты клетки, на которой находится робот
    - `x`
    - `y`
- `direction` - направление
- `mail` - посылка, которую везет робот или `None`, если нет посылки:
    - `id` - уникальный номер посылки
    - `destination` - направление, в которое нужно доставить
- `type` - тип робота, информация о времени действиях:
    - `time_to_move` - время, чтобы проехать 1 клетку
    - `time_to_turn` - время, чтобы повернуть на 90 градусов
    - `time_to_take` - время, чтобы взять посылку
    - `time_to_put` - время, чтобы положить одну посылку

### Реализация правил моделирования

С помощью классов [`Robot`](robot.py#L19), [`Map`](structures.py#L66), [`Cell`](cell.py#L20), [`MailFactory`](mail_factories/mail_factory.py), [`Brain`](brains/brain.py#L14) реализовано следующим образом:
- Каждая клетка может быть зарезервирована одним роботом и не зарезервирована тем же роботом; методы `Cell.reserve` и `Cell.unreserve`
- Клетка-пункт получения, вызывают `MailFactory` со своим *id*, чтобы получать сгенерированные направления позже.
- клетка-пункт получения, когда робот вызывает `Cell.get_input` для получения новой посылки, клетка вызывает сохраненный вызов `MailFactory`.
- Во время запуска каждый робот резервирует клетку, в которой он находится.
- После выполнения действия робот вызывает `Brain.get_next_action`:
    - если действие - бездействие, робот ждет, пока вызовет `Robot.abort`
    - если действие - движение, робот резервирует следующую клетку, ждет время для перемещения, отменяет резервирование предыдущей клетки; если следующей клетки не существует или она уже зарезервирована, возникает исключение `PositionOutOfMap` или `RobotCollision` соответственно;
    - если действие — поворот, робот ждет время для поворота
    - если действие — получить, робот пытается забрать посылку и ждет время для приема; если у робота уже есть посылка, возникает `DoubleMailTake`; если клетка не является пунктом приема, возникает `NotInputCell`.
    - если действие - положить, робот пытается отправить посылку из клетки и ждет время для отправки; если у робота нет посылки, возникает `MailToPutAbsence`; если направление посылки не совпадает с пунктом отправления или клетка не является пунктом отправления, возникает `IncorrectOutput`.